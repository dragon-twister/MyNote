# Mysql的优化

[TOC]

## 优化思路

成本从低到高：

1.优化sql和索引

2.做缓存，如redis

3.读写分离

4.垂直拆分，水平拆分


## sql优化

SQL执行的最大瓶颈在于磁盘的IO，即数据的读取；不同SQL的写法，会造成不同的执行计划的执行，而不同的执行计划在IO的上面临完全不一样的数量级，从而造成性能的差距；

所以,我们说,优化SQL,其实就是让查询优化器根据程序猿的计划选择匹配的执行计划,来减少查询中产生的IO;

首先是避免全表扫描的情况：

小表左关联大表 查询会比较快

不要用*只返回需要的字段；

### sql优化方法

(1)、explain出来的各种item的意义；  
select_type  
表示查询中每个select子句的类型  
type  
表示MySQL在表中找到所需行的方式，又称“访问类型”  
possible_keys  
指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用  
key  
显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL  
key_len  
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度  
ref  
表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值  
Extra  
包含不适合在其他列中显示但十分重要的额外信息  
  
(2)、profile的意义以及使用场景；  
查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等  

#### 表设计：

1 数据库设计时不要让字段的默认值为NULL，如果建立了索引的某一列里面有空值 那么这个索引就会失效
2 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。
3 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型

#### 索引

5，排序的索引问题
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

6，like语句操作
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

7，不要在列上进行运算
select * from users where YEAR(adddate)<2007;
将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成

select * from users where adddate<‘2007-01-01’;

8，不使用NOT IN和操作
NOT IN和操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id3则可使用id>3 or id<3来代替。

9.不要使用or

1，索引的好处：
	1，提高表数据的检索效率；
	2，如果排序的列是索引列(如果查询的列==排序的列[并且在这列上做了索引])，大大降低排序成本；
	3，在分组操作中如果分组条件是索引列，也会提高效率；

2，索引的问题：
      索引需要额外的维护成本；因为索引文件是单独存在的文件,对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率;
 