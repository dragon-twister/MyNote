# 集合

### HashMap与HashTable的区别。

1、HashMap是非线程安全的，HashTable是线程安全的。

2、HashMap的键和值都允许有null值存在，而HashTable则不行。

3、因为线程安全的问题，HashMap效率比HashTable的要高。

### Hashtable, HashMap,和ConcurrentHashMap 的底层实现原理

### linklist和arraylist

一个基于数组，一个基于链表，

所以：

arraylist的查询（修改）效率比linklist高，而linklist的增加删除效率比array。

linklist比arraylist消耗更多的内存，因为他的每个节点都需要存储下个节点的引用。

arraylist初试容量是10，每次扩容1.5倍

### HashMap

基于链表和数组

put：

1、当我们调用put方法时先判断key可以为空，如果为空就存储在数组的第一个元素
2、根据key计算出哈希值，找出数组的下标
3、通过循环遍历链表，如果找到key相同的节点覆盖掉
4、如果没有就在链表头部添加一个节点，节点信息包括key，value，指向下一个节点的引用、hash值

get：
1、如果key等于null，直接取数组的第一个元素
2、如果不是，先计算出key的hashcode找到下标
3、再用key的equals方法判断是否相等，如果相等，则返回对应的entry，如果不相等，

### 多线程hashmap会出现什么问题


### hashset保证唯一性？

底层依赖两个方法：hashCode()和equals()

首先比较哈希码是否相同，相同就执行equals方法判断对象是否相等，不同就直接添加元素

### HashMap的resize（rehash）

当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。

那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过160.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。


### hashmap查找元素

首先计算key的哈希值(hashcode(key.hashcode()))，通过key找到数组中对应位置的某一元素。


### 简单地说

，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，
也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。

> http://tracylihui.github.io/2015/07/01/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A01%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/


### currenthashmap

jdk1.8中使用同步代码块和cas算法保证线程安全，cas是乐观锁的一种

cas算法设计到三个数   内存值   预期值  要修改的新值

当内存值等于预期值的时候就把内存值修改为要修改新值

hashmap的扩容方法在并发的时候会导致死循环。