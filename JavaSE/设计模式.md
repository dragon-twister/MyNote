# 设计模式

[toc]

## 装饰者模式
    
    当我们对一个类做扩展的时候会用到继承，但是当扩展功能需要动态变化的时候就需要创建很多的扩展类，
    
    装饰者模式可以解决扩展类过多的问题，把需要扩展的类作为构造参数传入创建的装饰类做动态扩展。而不是通过继承。
    
    例如fileoutputstream和bufferoutputstream
    

## 动态代理模式

### 动态代理的实现步骤

jdk:

1.实现invocationhandler接口，重写invoke方法

2.把上一步创建的对象传入proxy.newInstance方法中创建动态代理类

cglib：

1.实现MethodInterceptor接口,重写interceptor方法

2.调用enhancer.create创建动态代理类

Method method = clazz.getMethod("sayHi", String.class);

method.invoke的意思是执行方法

### jdk和cglib的区别

jdk要求代理类需要是实现了接口的类

cglib可以代理类

## 单例模式

### 单例模式的实现

    public class Singleton {  
     
    private Singleton(){}  
     
    //在自己内部定义自己一个实例，是不是很奇怪？  
     
    //注意这是private 只供内部调用  
     
    private static Singleton instance = new Singleton();  
     
    //这里提供了一个供外部访问本class的静态方法，可以直接访问  
     
    public static Singleton getInstance() {  
     
    return instance;   
     
     }  
     
    }  
 
第二种：

    public class Singleton {  
     
    private static Singleton instance = null;  
     
    public static synchronized Singleton getInstance() {  
     
    //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　 　  
     
    //使用时生成实例，提高了效率！  
     
    if (instance==null)  
     
    instance＝new Singleton();  
     
    return instance; }  
     
    }  