# 多线程

[toc]

### 线程池

　　ThreadPool：多见于线程并发，阻塞时延比较长的，这种线程池比较常用，一般设置的线程个数根据业务性能要求会比较多。
　　ForkJoinPool：特点是少量线程完成大量任务，一般用于非阻塞的，能快速处理的业务，或阻塞时延比较少的
　　
### 线程的生命周期

线程是一个动态执行的过程，它也有一个从产生到死亡的过程。

(1)生命周期的五种状态

新建（new Thread）

当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
例如：Thread  t1=new Thread();

就绪（runnable）

线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();

运行（running）

线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

死亡（dead）

当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。

自然终止：正常运行run()方法后终止

异常终止：调用stop()方法让一个线程终止运行

堵塞（blocked）

由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。

正在等待：调用wait()方法。（调用motify()方法回到就绪状态）

被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

### 线程优先级

Thread.setPriority()

线程的优先级从1到10，默认优先级为5

### 线程池的优点

不需要创建和销毁线程，降低资源消耗，提高相应速度

### servlet的生命周期

初始化阶段 调用init方法

响应客户端请求阶段 调用service方法,根据请求区调用doget或者dopost方法

servlet终止阶段 当WEB应用被终止，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。

编写一个Servlet程序大体上需要3个步骤：继承HttpServlet-->重写doGet（）或者doPost（）方法-->在web.xml中注册Servlet。

### synchronized和reentrantlock的区别

synchronize是基于jvm来实现的.每一个对象都有一个监听器

synchronize是非公平锁,即无法保证线程获取锁的顺序是按照请求锁的顺序来的.



### synchronized 用在方法和代码块上的区别

用在方法签名上，当某个线程调用此方法时，会获取该实例的对象锁

用在代码块当线程运行到该代码块内，就会拥有obj（指synchronized(obj)）对象的对象锁

    public void test() {
         ...
         synchronized(this) {
              // todo your code
         }
         ...
    }
     
等同于

    public synchronized void test() {
         // todo your code
    }


### volatile关键字

首先要从线程的内存模型谈：

每个线程都有自己的工作内存，这些线程有一块主内存共享数据。

对共享变量的读取和赋值操只能在工作变量中执行，所以每次都会从主内存中拷贝一个副本到工作内存

不同线程之间又无法直接访问对方的变量。

线程操作后的值不是马上刷新到主内存。

这样就造成了缓存一致性问题。


对于可见性，Java提供了volatile关键字来保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

http://www.importnew.com/24082.html

### 两个线程共享数据？

静态变量是存储在内存中  不是数据库

内存和数据库一样，有并发问题。

1、通过内部类访问外部变量

2、通过静态变量



### threadlocal?

？？？ 

### 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行  

public class JoinTest2 {  
  
    public static void main(String[] args) {  
  
        final Thread t1 = new Thread(new Runnable() {  
  
            @Override  
            public void run() {  
                System.out.println("t1");  
            }  
        });  
        final Thread t2 = new Thread(new Runnable() {  
  
            @Override  
            public void run() {  
                try {  
                    //引用t1线程，等待t1线程执行完  
                    t1.join();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
                System.out.println("t2");  
            }  
        });  
        Thread t3 = new Thread(new Runnable() {  
  
            @Override  
            public void run() {  
                try {  
                    //引用t2线程，等待t2线程执行完  
                    t2.join();  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
                System.out.println("t3");  
            }  
        });  
        t3.start();  
        t2.start();  
        t1.start();  
    }  
    
### wait和sleep的区别

sleep集成thread类，wait继承object类

调用sleep方法的过程中，线程不会释放对象锁

wait方法线程会暂时释放对象锁，只有针对此对象发出notify方法（或notifyAll），或者wait（1000）时间超时。

### 线程池

ThreadPoolExcuter：这个类里面主要有线程池的各种配置包括核心线程数，最大线程数，线程数超过核心线程数后就会排队等待，ThreadPoolExcuter提供了等待队列（workQueue），正在执行的线程会保存在一个hashset集合里面（works），线程池对外暴露的任务入口是excute方法

> http://www.php.cn/java-article-391328.html