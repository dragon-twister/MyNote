# Zookeeper
[toc]


## zookeeper的应用场景

**做注册中心**：

如果微服务没有注册中心之前，那我们可能会直接把服务的url直接写死在项目里这样就会造成两个问题，1.微服务多，改起来不方便。zookeeper的注册中心可以用来解决这个问题，服务提供者会网注册中心注册创建一个临时节点，消费者通过注册中心获取服务提供者url，此外服务提供者会和注册中心维持一个心跳,服务挂掉了，注册中心也能够及时发现并删除节点。

**管理服务集群：** 

一个服务可能有多个，如果没有注册中心的话那可能就直接把服务的url写死在项目里，及时服务挂了依然会调用
做分布式锁：首先在zookeeper创建一个文件夹，锁的话是多个服务竞争，谁先在目录创建了文件夹谁就获得了锁，其他服务也会创建文件夹，文件夹有一个序列号，谁的序列号最小,谁就获得了锁，
做集群管理：有多个节点的时候选出一个master，节点挂掉的时候通过zookeeper可以通过心跳发现并移除节点

**配置中心:**

我们可以把配置信息保存到zookeeper的节点上，每个服务服务都能访问到这个文件，如果配置文件发生变动，zookeeper通知其他服务重新加载配置文件。

**分布式锁:**

这个主要用到了zookeeper的watch机制，对节点监听



### 基础

#### zxid

• znode节点的状态信息中包含czxid, 那么什么是zxid呢?
　　
• ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生.


#### 集群中的几种角色

Leader：Leader是由选举产生的，接受所有 Follower 的提案请求并统一协调发起提案的投票，负责与所有的 Follower 进行内部的数据交换

Follower：直接为客户端服务并参与提案的投票，同时与 Leader 进行数据交换

Observer：直接为客户端服务但不参与提案的投票，同时也与 Leader 进行数据交换


#### CAP理论

任何分布式系统只可同时满足两点，无法三者兼顾。

C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。

A：Availability，可用性，系统具有好的响应性能。

P：Partition tolerance，分区容错性。

因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。

#### 一致性

一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：

强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。

单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可　　获取的数据顺序必是单调递增的。

会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这值更旧的值　　 会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。示例case：php的　　session概念。

最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。

弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。

#### ZooKeeper提供的一致性服务
　　
很多文章和博客里提到，zookeeper是一种提供强一致性的服务，在分区容错性和可用性上做了一定折中，这和CAP理论是吻合的。但实际上zookeeper提供的只是单调一致性。
原因：
　　
1. 假设有2n+1个server，在同步流程中，leader向follower同步数据，当同步完成的follower数量大于 n+1时同步流程结束，系统可接受client的连接请求。如果client连接的并非同步完成的follower，那么得到的并非最新数据，但可以保证单调性。
　
2. follower接收写请求后，转发给leader处理；leader完成两阶段提交的机制。向所有server发起提案，当提案获得超过半数（n+1）的server认同后，将对整个集群进行同步，超过半数（n+1）的server同步完成后，该写请求完成。如果client连接的并非同步完成follower，那么得到的并非最新数据，但可以保证单调性。

用分布式系统的CAP原则来分析Zookeeper：

（1）C: Zookeeper保证了最终一致性,在十几秒可以Sync到各个节点.

（2）A: Zookeeper保证了可用性,数据总是可用的,没有锁.并且有一大半的节点所拥有的数据是最新的,实时的. 如果想保证取得是数据一定是最新的,需要手工调用Sync()

（3）P: 有2点需要分析的.
    ① 节点多了会导致写数据延时非常大,因为需要多个节点同步.
    ② 节点多了Leader选举非常耗时, 就会放大网络的问题. 可以通过引入 observer节点缓解这个问题.


### 用作注册中心

用作注册中心用时，提供者、消费者都向Zookeeper注册自己的URL，消费者通过服务提供者的URL调用服务。而提供者发生了变动，也会通过Zookeeper向订阅的消费者发送通知。


### 用作集群

#### 为什么需要leader

leader接收请求，把节点分发给其他节点

#### 节点选举

#### 为什么集群的数目一般为奇数个

- Leader选举算法采用了Paxos协议；
- Paxos核心思想：当多数Server写成功，则任务数据写成功如果有3个Server，则两个写成功即可；如果有4或5个Server，则三个写成功即可。
- Server数目一般为奇数（3、5、7）如果有3个Server，则最多允许1个Server挂掉；如果有4个Server，则同样最多允许1个Server挂掉由此，

- 台服务器和4台服务器的的容灾能力是一样的，所以为了节省服务器资源，一般我们采用奇数个数，作为服务器部署个数。



#### ZooKeeper集群中服务器之间是怎样通信的？

Leader服务器会和每一个Follower/Observer服务器都建立TCP连接，同时为每个F/O都创建一个叫做LearnerHandler的实体。

LearnerHandler主要负责Leader和F/O之间的网络通讯，包括数据同步，请求转发和Proposal提议的投票等。Leader服务器保存了所有F/O的LearnerHandler。

### 
